1.在pc.c中去掉所有与信号量有关的代码，再运行程序，执行效果有变化吗？为什么会这样？
有可能发生这么几种情况
1) 不按顺序输出
因为有可能缓冲区满了,生产者仍往里写入数据导致之前未被处理的数据被覆盖掉
因为我的pc.c并没有把处理过的缓冲区数据删除掉,只是挪动了指针,所以有可能缓冲区空了,消费者仍在读取数据,这样也会造成数据输出不正确
2)read error
没有了互斥锁,会出现多个进程并发访问临界区,导致read error

2.实验的设计者在第一次编写生产者——消费者程序的时候，是这么做的：
这样可行吗？如果可行，那么它和标准解法在执行效果上会有什么不同？如果不可行，那么它有什么问题使它不可行？

不行,会发生死锁.例如当mutex = 1 ,empty = 0; 生产者要生产一个数据, sem_wait(mutex) sem_wait(empty)之后, mutext = 0 empty小于0 ,生产者进入等待队列,schedule之后,消费者执行,而这时 mutex = 0 ,所以 sem_wait(mutex) = -1 他们都等待mutex,导致死锁.

内核代码竟然一遍就过了,感觉太激动了,倒是pc.c 刚开始因为lseek调整读写指针一直搞不对,结果发现是忘了 *in_pos ,到linux0.11又发现 竟然不能用 // 注释, 然后还有其他的编译错误,结果调整了代码位置竟然就对了,搞得我现在还是莫名其妙.实验四确实比之前的都难,主要是代码比较多,而且关键是思路要清楚, 思路一旦清楚了,代码就很好写了,把编译错误改改,也就过了.
